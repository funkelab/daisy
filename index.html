

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Daisy: A Blockwise Task Scheduler &mdash; daisy  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=5929fcd5"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Daisy Tutorial" href="tutorial.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="#" class="icon icon-home">
            daisy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Daisy Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html#Some-Minimal-Examples">Some Minimal Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html#Map-Reduce-and-Some-simple-benchmarks">Map Reduce and Some simple benchmarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="release.html">Release notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">daisy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="#" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Daisy: A Blockwise Task Scheduler</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p><img alt="daisy" src="docs/source/_static/daisy.jpg" /></p>
<section id="daisy-a-blockwise-task-scheduler">
<h1>Daisy: A Blockwise Task Scheduler<a class="headerlink" href="#daisy-a-blockwise-task-scheduler" title="Link to this heading"></a></h1>
<blockquote>
<div><p>Blockwise task scheduler for processing large volumetric data</p>
</div></blockquote>
<section id="what-is-daisy">
<h2>What is Daisy?<a class="headerlink" href="#what-is-daisy" title="Link to this heading"></a></h2>
<p>Daisy is a library framework that facilitates distributed processing of big nD datasets across clusters of computers.
It combines the best of MapReduce/Hadoop (the ability to map a process function across elements) and Luigi (the ability to chain dependent tasks together) together in one lightweight and efficient package with a focus on processing nD datasets.</p>
<p>Daisy documentations are at https://funkelab.github.io/daisy</p>
</section>
<section id="updates">
<h2>Updates<a class="headerlink" href="#updates" title="Link to this heading"></a></h2>
<section id="daisy-v1-0-is-now-available-on-pypi">
<h3>Daisy v1.0 is now available on PyPI!<a class="headerlink" href="#daisy-v1-0-is-now-available-on-pypi" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>Install it now with <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">daisy</span></code></p></li>
<li><p>Besides quality-of-life improvements, we have also refactored I/O-related utilities to <code class="docutils literal notranslate"><span class="pre">funlib.persistence</span></code> to make code maintenance easier. This includes everything that was in <code class="docutils literal notranslate"><span class="pre">daisy.persistence</span></code> along with <code class="docutils literal notranslate"><span class="pre">daisy.Array</span></code> and helper functions such as <code class="docutils literal notranslate"><span class="pre">daisy.open_ds</span></code>, and <code class="docutils literal notranslate"><span class="pre">daisy.prepare_ds</span></code>.</p>
<ul>
<li><p>Just run <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">funlib.persistence</span></code>.</p></li>
<li><p>These functions, which provide an easy to use interface to common formats such as zarr, n5 and any other dask friendly format for arrays and interfaces for storing large spatial graphs in SQLite, PostgreSQL, or Files remain the same.</p></li>
</ul>
</li>
</ul>
</section>
</section>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Link to this heading"></a></h2>
<p>Developed by researchers at HHMI Janelia and Harvard, the intention behind Daisy was to develop a scalable and fast distributed block-wise scheduler for processing very large (TBs to PBs) 3D/4D bio image datasets.
We needed a fast and scalable scheduler but also resilient to failures and recoverable/resumable from hardware errors.
Daisy should also be generalizable enough to support efficient processing of different tasks with different computation and input/output modalities.</p>
<section id="daisy-is-lightweight">
<h3>Daisy is lightweight<a class="headerlink" href="#daisy-is-lightweight" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>Daisy uses high performance TCP/IP libraries for communications between the scheduler and workers.</p></li>
<li><p>It minimizes network overheads by sending only coordinates and status checks. Daisy does not enforce the exact method of data transfers to/between workers so that maximum performance is achieved for different tasks.</p></li>
</ul>
</section>
<section id="daisy-s-api-is-easy-to-use-and-extensible">
<h3>Daisy’s API is easy-to-use and extensible<a class="headerlink" href="#daisy-s-api-is-easy-to-use-and-extensible" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>Built on Python, Daisy provides an easy-to-use native interface for Python scripts useful for both simple and complex use cases.</p></li>
<li><p>Simplistically, Daisy is a framework for <code class="docutils literal notranslate"><span class="pre">map</span></code>ping a function across independent sub-blocks in the dataset.</p></li>
<li><p>More complex usages include specifying inter-block dependencies, inter-task dependencies, using Daisy’s array interface and geometric graph interface.</p></li>
</ul>
</section>
<section id="daisy-chains-complex-pipelines-of-tasks">
<h3>Daisy chains complex pipelines of tasks<a class="headerlink" href="#daisy-chains-complex-pipelines-of-tasks" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>Inspired by powerful workflow management frameworks like <a class="reference external" href="https://github.com/spotify/luigi">Luigi</a> for automating long running tasks and decreasing overall processing time through task pipelining, Daisy allows user to specify dependency between tasks, allowing for task chaining and running multiple tasks in a pipeline with dynamic concurrent per-block execution.</p></li>
<li><p>For instance, Daisy can chain a <code class="docutils literal notranslate"><span class="pre">map</span></code> task and a <code class="docutils literal notranslate"><span class="pre">reduce</span></code> task to implement a <code class="docutils literal notranslate"><span class="pre">map-reduce</span></code> task for nD datasets. Of course, any other combinations of <code class="docutils literal notranslate"><span class="pre">map</span></code> and <code class="docutils literal notranslate"><span class="pre">reduce</span></code> tasks are composable.</p></li>
<li><p>By tracking dependencies at the <code class="docutils literal notranslate"><span class="pre">block</span></code> level, tasks can be executed concurrently to maximize pipelining parallelism.</p></li>
</ul>
</section>
<section id="daisy-is-tuned-for-processing-datasets-with-real-world-units">
<h3>Daisy is tuned for processing datasets with real-world units<a class="headerlink" href="#daisy-is-tuned-for-processing-datasets-with-real-world-units" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>Daisy has a native inferface to represent of regions in a volume in real world units, easily handling voxel sizes, with convenience functions for region manipulation (intersection, union, growing or shrinking, etc.)</p></li>
</ul>
</section>
</section>
<section id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Link to this heading"></a></h2>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>pip<span class="w"> </span>install<span class="w"> </span>daisy
</pre></div>
</div>
<p>Alternatively, you can install from github for the latest development version:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>pip<span class="w"> </span>install<span class="w"> </span>-e<span class="w"> </span>git+https://github.com/funkelab/daisy#egg<span class="o">=</span>daisy
</pre></div>
</div>
</section>
<section id="quickstart">
<h2>Quickstart<a class="headerlink" href="#quickstart" title="Link to this heading"></a></h2>
<p>See the following code in a <a class="reference internal" href="#/examples/daisy_quickstart.ipynb"><span class="xref myst">IPython notebook</span></a>!</p>
<section id="map-task">
<h3>Map task<a class="headerlink" href="#map-task" title="Link to this heading"></a></h3>
<p>First, let’s run a simple <code class="docutils literal notranslate"><span class="pre">map</span></code> task with Daisy. Supposed we have an array <code class="docutils literal notranslate"><span class="pre">a</span></code> that we want to compute the square for each element and store in <code class="docutils literal notranslate"><span class="pre">b</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="n">shape</span> <span class="o">=</span> <span class="mi">4096000</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="c1"># prints [0 1 2 ... 4095997 4095998 4095999]</span>
</pre></div>
</div>
<p>We can use the following <code class="docutils literal notranslate"><span class="pre">process_fn</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">process_fn</span><span class="p">():</span>
    <span class="c1"># iterating and squaring each element in a and store to b</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span>
                   <span class="n">op_flags</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;readonly&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;readwrite&#39;</span><span class="p">]])</span> <span class="k">as</span> <span class="n">it</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">it</span><span class="p">:</span>
           <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
                <span class="n">y</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>
<span class="o">%</span><span class="n">timeit</span> <span class="n">process_fn</span><span class="p">()</span>  <span class="c1"># 3.55 s ± 22.7 ms per loop</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="c1"># prints [0 1 4 ... 16777191424009 16777199616004 16777207808001]</span>
</pre></div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">process_fn</span></code> linearly processes <code class="docutils literal notranslate"><span class="pre">a</span></code> in a single-thread, it is quite slow.
Let’s use Daisy to break <code class="docutils literal notranslate"><span class="pre">a</span></code> into blocks and run <code class="docutils literal notranslate"><span class="pre">process_fn</span></code> in parallel.</p>
<p>First, we’ll wrap <code class="docutils literal notranslate"><span class="pre">a</span></code> in a <code class="docutils literal notranslate"><span class="pre">daisy.Array</span></code> and make a <code class="docutils literal notranslate"><span class="pre">b</span></code> array based on <code class="docutils literal notranslate"><span class="pre">zarr</span></code> that multiple concurrent process can write to. We will also define <code class="docutils literal notranslate"><span class="pre">block_shape</span></code> - the granularity that each worker will be working at.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">daisy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">funlib.persistence</span><span class="w"> </span><span class="kn">import</span> <span class="n">Array</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">funlib.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">Roi</span><span class="p">,</span> <span class="n">Coordinate</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">zarr</span>
<span class="n">shape</span> <span class="o">=</span> <span class="mi">4096000</span>
<span class="n">block_shape</span> <span class="o">=</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">16</span>
<span class="c1"># input array is wrapped in `Array` for easy of `Roi` indexing</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span>
                <span class="n">roi</span><span class="o">=</span><span class="n">Roi</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="n">shape</span><span class="p">),</span>
                <span class="n">voxel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
<span class="c1"># to parallelize across processes, we need persistent read/write arrays</span>
<span class="c1"># we&#39;ll use zarr here to do do that</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">open_array</span><span class="p">(</span><span class="n">zarr</span><span class="o">.</span><span class="n">TempStore</span><span class="p">(),</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">shape</span><span class="p">,),</span>
                    <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="n">block_shape</span><span class="p">,),</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
<span class="c1"># output array is wrapped in Array for easy of Roi indexing</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="n">b</span><span class="p">,</span>
                <span class="n">roi</span><span class="o">=</span><span class="n">Roi</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="n">shape</span><span class="p">),</span>
                <span class="n">voxel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">process_fn</span></code> is then modified slightly to take in a <code class="docutils literal notranslate"><span class="pre">block</span></code> object and perform read/write using the ROIs given by it.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># same process function as previously, but with additional code</span>
<span class="c1"># to read and write data to persistent arrays</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process_fn_daisy</span><span class="p">(</span><span class="n">block</span><span class="p">):</span>
    <span class="n">a_sub</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">block</span><span class="o">.</span><span class="n">read_roi</span><span class="p">]</span><span class="o">.</span><span class="n">to_ndarray</span><span class="p">()</span>
    <span class="n">b_sub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">a_sub</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">([</span><span class="n">a_sub</span><span class="p">,</span> <span class="n">b_sub</span><span class="p">],</span>
                   <span class="n">op_flags</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;readonly&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;readwrite&#39;</span><span class="p">]],</span>
                  <span class="p">)</span> <span class="k">as</span> <span class="n">it</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">it</span><span class="p">:</span>
           <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
                <span class="n">y</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>

    <span class="n">b</span><span class="p">[</span><span class="n">block</span><span class="o">.</span><span class="n">write_roi</span><span class="p">]</span> <span class="o">=</span> <span class="n">b_sub</span>
</pre></div>
</div>
<p>Next, we define <code class="docutils literal notranslate"><span class="pre">total_roi</span></code> based on total amount of work (<code class="docutils literal notranslate"><span class="pre">shape</span></code>) and <code class="docutils literal notranslate"><span class="pre">block_roi</span></code> based on scheduling block size (<code class="docutils literal notranslate"><span class="pre">block_shape</span></code>). We then make a <code class="docutils literal notranslate"><span class="pre">daisy.Task</span></code> and run it.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">total_roi</span> <span class="o">=</span> <span class="n">Roi</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="n">shape</span><span class="p">)</span>  <span class="c1"># total ROI to map process over</span>
<span class="n">block_roi</span> <span class="o">=</span> <span class="n">Roi</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="n">block_shape</span><span class="p">,))</span>  <span class="c1"># block ROI for parallel processing</span>
<span class="c1"># creating a Daisy task, note that we do not specify how each</span>
<span class="c1"># worker should read/write to input/output arrays</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">daisy</span><span class="o">.</span><span class="n">Task</span><span class="p">(</span>
    <span class="n">total_roi</span><span class="o">=</span><span class="n">total_roi</span><span class="p">,</span>
    <span class="n">read_roi</span><span class="o">=</span><span class="n">block_roi</span><span class="p">,</span>
    <span class="n">write_roi</span><span class="o">=</span><span class="n">block_roi</span><span class="p">,</span>
    <span class="n">process_function</span><span class="o">=</span><span class="n">process_fn_daisy</span><span class="p">,</span>
    <span class="n">num_workers</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
    <span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;square&#39;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">daisy</span><span class="o">.</span><span class="n">run_blockwise</span><span class="p">([</span><span class="n">task</span><span class="p">])</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">prints Execution Summary</span>
<span class="sd">-----------------</span>
<span class="sd">  Task square:</span>
<span class="sd">    num blocks : 250</span>
<span class="sd">    completed ✔: 250 (skipped 0)</span>
<span class="sd">    failed    ✗: 0</span>
<span class="sd">    orphaned  ∅: 0</span>
<span class="sd">    all blocks processed successfully</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="c1"># %timeit daisy.run_blockwise([task])  # 1.26 s ± 16.1 ms per loop</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">to_ndarray</span><span class="p">())</span>
<span class="c1"># prints [0 1 4 ... 16777191424009 16777199616004 16777207808001]</span>
</pre></div>
</div>
<p>See that with just a minor modification, using Daisy to run multiple workers in parallel results in a 2.8176x speedups on a computer with 6 cores. For longer running tasks with larger block sizes (to minimize process spawning/joining overheads) the speedups should approach the # of threads/cores running in parallel more.</p>
</section>
<section id="reduce-task">
<h3>Reduce task<a class="headerlink" href="#reduce-task" title="Link to this heading"></a></h3>
<p>Now we’ll write and run a <code class="docutils literal notranslate"><span class="pre">reduce</span></code> task. This task performs a sum of blocks of shape <code class="docutils literal notranslate"><span class="pre">reduce_shape</span></code> from <code class="docutils literal notranslate"><span class="pre">b</span></code> and stores the results to <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span>
<span class="n">reduce_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="o">/</span><span class="mi">16</span>
<span class="c1"># while using zarr with `Array` can be easier to understand and less error prone, it is not a requirement.</span>
<span class="c1"># Here we make a shared memory array for collecting results from different workers</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="s1">&#39;Q&#39;</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">shape</span><span class="o">/</span><span class="n">reduce_shape</span><span class="p">)))</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process_fn_sum_reduce</span><span class="p">(</span><span class="n">block</span><span class="p">):</span>
    <span class="n">b_sub</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">block</span><span class="o">.</span><span class="n">write_roi</span><span class="p">]</span><span class="o">.</span><span class="n">to_ndarray</span><span class="p">()</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">b_sub</span><span class="p">)</span>
    <span class="c1"># compute c idx based on block offset and shape</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">write_roi</span><span class="o">.</span><span class="n">offset</span> <span class="o">/</span> <span class="n">block</span><span class="o">.</span><span class="n">write_roi</span><span class="o">.</span><span class="n">shape</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">c</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
<span class="n">total_roi</span> <span class="o">=</span> <span class="n">Roi</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="n">shape</span><span class="p">)</span>  <span class="c1"># total ROI to map process over</span>
<span class="n">block_roi</span> <span class="o">=</span> <span class="n">Roi</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="n">reduce_shape</span><span class="p">)</span>  <span class="c1"># block ROI for parallel processing</span>
<span class="n">task1</span> <span class="o">=</span> <span class="n">daisy</span><span class="o">.</span><span class="n">Task</span><span class="p">(</span>
    <span class="n">total_roi</span><span class="o">=</span><span class="n">total_roi</span><span class="p">,</span>
    <span class="n">read_roi</span><span class="o">=</span><span class="n">block_roi</span><span class="p">,</span>
    <span class="n">write_roi</span><span class="o">=</span><span class="n">block_roi</span><span class="p">,</span>
    <span class="n">process_function</span><span class="o">=</span><span class="n">process_fn_sum_reduce</span><span class="p">,</span>
    <span class="n">num_workers</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
    <span class="n">task_id</span><span class="o">=</span><span class="s1">&#39;sum_reduce&#39;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">daisy</span><span class="o">.</span><span class="n">run_blockwise</span><span class="p">([</span><span class="n">task1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="p">[:])</span>
</pre></div>
</div>
<p>This concludes our quickstart tutorial. For more examples/tutorials please see the <a class="reference internal" href="#/examples"><span class="xref myst">examples/</span></a> directory.</p>
</section>
</section>
<section id="citing-daisy">
<h2>Citing Daisy<a class="headerlink" href="#citing-daisy" title="Link to this heading"></a></h2>
<p>To cite this repository please use the following bibtex entry:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@software</span><span class="p">{</span><span class="n">daisy2022github</span><span class="p">,</span>
  <span class="n">author</span> <span class="o">=</span> <span class="p">{</span><span class="n">Tri</span> <span class="n">Nguyen</span> <span class="ow">and</span> <span class="n">Caroline</span> <span class="n">Malin</span><span class="o">-</span><span class="n">Mayor</span> <span class="ow">and</span> <span class="n">William</span> <span class="n">Patton</span> <span class="ow">and</span> <span class="n">Jan</span> <span class="n">Funke</span><span class="p">},</span>
  <span class="n">title</span> <span class="o">=</span> <span class="p">{</span><span class="n">Daisy</span><span class="p">:</span> <span class="n">block</span><span class="o">-</span><span class="n">wise</span> <span class="n">task</span> <span class="n">dependencies</span> <span class="k">for</span> <span class="n">luigi</span><span class="o">.</span><span class="p">},</span>
  <span class="n">url</span> <span class="o">=</span> <span class="p">{</span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">funkelab</span><span class="o">/</span><span class="n">daisy</span><span class="p">},</span>
  <span class="n">version</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.0</span><span class="p">},</span>
  <span class="n">year</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2022</span><span class="p">},</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the above bibtex entry, the version number is intended to be that from <a class="reference internal" href="#/setup.py"><span class="xref myst">daisy/setup.py</span></a>, and the year corresponds to the project’s 1.0 release.</p>
</section>
</section>
<div class="toctree-wrapper compound">
</div>
<ul class="simple">
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="tutorial.html" class="btn btn-neutral float-right" title="Daisy Tutorial" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, Jan Funke, Tri Nguyen, William Patton, Caroline Malin-Mayor, Arlo Sheridan, Philipp Hanslovsky, Chris Barnes.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>